// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {FHE, euint64, ebool, InEbool, InEuint64} from "@fhenixprotocol/cofhe-contracts/FHE.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title CarrotInABoxGame
 * @notice On-chain bluffing game with coFHE-encrypted box contents
 * @dev Re-implemented for coFHE on standard networks.
 */
contract CarrotInABoxGame is Ownable, ReentrancyGuard {
    IERC20 public carrotToken;
    
    enum GameState {
        Open,       // Waiting for Player B to join
        Active,     // Both players in, bluffing phase
        Decided,    // Player B made decision, awaiting resolution (decryption)
        Resolved,   // Game complete, winner determined
        Cancelled   // Game cancelled
    }
    
    struct Game {
        address playerA;
        address playerB;
        uint256 stake;
        ebool playerAHasCarrot;     // Encrypted: does Player A's box have the carrot?
        bool playerBDecision;        // False = keep own box, True = take A's box
        bool decisionMade;
        GameState state;
        uint256 createdAt;
        uint256 joinedAt;
        uint256 decidedAt;
        address winner;
        bool playerAHasCarrotRevealed;
        // Shared Game Key (KeyPair generated by creator)
        bytes32 gamePubKey;
        // Encrypted Private Key Shards (32 bytes = 4 * 64 bits)
        // Access is granted to Player B upon joining via FHE.allow
        euint64 k1;
        euint64 k2;
        euint64 k3;
        euint64 k4;
    }
    
    struct Bluff {
        address sender;
        string message;
        uint256 timestamp;
    }
    
    mapping(uint256 => Game) public games;
    mapping(uint256 => Bluff[]) public gameBluffs;
    mapping(address => uint256) public activeGameCount;
    uint256 public totalVolume;
    uint256 public nextGameId = 1;
    uint256 public constant MIN_STAKE = 1 * 10**18;
    uint256 public constant MAX_ACTIVE_GAMES = 3;
    uint256 public constant DECISION_TIMEOUT = 1 hours;
    
    event GameCreated(uint256 indexed gameId, address indexed playerA, uint256 stake, bytes32 gamePubKey);
    event GameJoined(uint256 indexed gameId, address indexed playerB);
    event BluffSent(uint256 indexed gameId, address indexed sender, string message);
    event DecisionMade(uint256 indexed gameId, bool takeOpponentBox);
    event GameResolved(uint256 indexed gameId, address indexed winner, uint256 pot, bool playerAHadCarrot);
    event GameCancelled(uint256 indexed gameId, string reason);

    
    constructor(address _carrotToken) Ownable(msg.sender) {
        carrotToken = IERC20(_carrotToken);
    }
    
    function createGame(
        InEbool calldata encryptedHasCarrot,
        uint256 stakeAmount,
        bytes32 gamePubKey,
        InEuint64 calldata inK1,
        InEuint64 calldata inK2,
        InEuint64 calldata inK3,
        InEuint64 calldata inK4
    ) external nonReentrant returns (uint256) {
        require(stakeAmount >= MIN_STAKE, "Stake below minimum");
        require(activeGameCount[msg.sender] < MAX_ACTIVE_GAMES, "Max active games reached");
        
        require(carrotToken.transferFrom(msg.sender, address(this), stakeAmount), "Transfer failed");
        
        uint256 gameId = nextGameId++;
        
        ebool hasCarrot = FHE.asEbool(encryptedHasCarrot);
        
        // Unwrap key shards
        euint64 _k1 = FHE.asEuint64(inK1);
        euint64 _k2 = FHE.asEuint64(inK2);
        euint64 _k3 = FHE.asEuint64(inK3);
        euint64 _k4 = FHE.asEuint64(inK4);
        
        // Allow Creator explicitly (though they generated it, redundancy for multi-device)
        FHE.allowThis(hasCarrot);
        // We also allow the key shards to this contract and sender
        FHE.allowThis(_k1); FHE.allow(_k1, msg.sender);
        FHE.allowThis(_k2); FHE.allow(_k2, msg.sender);
        FHE.allowThis(_k3); FHE.allow(_k3, msg.sender);
        FHE.allowThis(_k4); FHE.allow(_k4, msg.sender);
        FHE.allow(hasCarrot, msg.sender);
        
        games[gameId] = Game({
            playerA: msg.sender,
            playerB: address(0),
            stake: stakeAmount,
            playerAHasCarrot: hasCarrot,
            playerBDecision: false,
            decisionMade: false,
            state: GameState.Open,
            createdAt: block.timestamp,
            joinedAt: 0,
            decidedAt: 0,
            winner: address(0),
            playerAHasCarrotRevealed: false,
            gamePubKey: gamePubKey,
            k1: _k1,
            k2: _k2,
            k3: _k3,
            k4: _k4
        });
        
        activeGameCount[msg.sender]++;
        totalVolume += stakeAmount;
        emit GameCreated(gameId, msg.sender, stakeAmount, gamePubKey);
        return gameId;
    }
    
    function joinGame(uint256 gameId) external nonReentrant {
        Game storage game = games[gameId];
        require(game.state == GameState.Open, "Not open");
        require(game.playerA != msg.sender, "Cannot join own game");
        require(activeGameCount[msg.sender] < MAX_ACTIVE_GAMES, "Max active games reached");
        
        require(carrotToken.transferFrom(msg.sender, address(this), game.stake), "Transfer failed");
        
        game.playerB = msg.sender;
        game.state = GameState.Active;
        // Allow Player B to access the shared game key
        FHE.allow(game.k1, msg.sender);
        FHE.allow(game.k2, msg.sender);
        FHE.allow(game.k3, msg.sender);
        FHE.allow(game.k4, msg.sender);
        
        game.joinedAt = block.timestamp;
        activeGameCount[msg.sender]++;
        
        emit GameJoined(gameId, msg.sender);
    }
    
    function sendBluff(uint256 gameId, string calldata message) external {
        Game storage game = games[gameId];
        require(game.state == GameState.Active || game.state == GameState.Open, "Bluffing not allowed");
        require(msg.sender == game.playerA || msg.sender == game.playerB, "Not a player");
        
        gameBluffs[gameId].push(Bluff({
            sender: msg.sender,
            message: message,
            timestamp: block.timestamp
        }));
        
        emit BluffSent(gameId, msg.sender, message);
    }
    
    /**
     * @notice Player B makes a decision. This triggers the asynchronous decryption.
     */
    function makeDecision(uint256 gameId, bool takeOpponentBox) external nonReentrant {
        Game storage game = games[gameId];
        require(game.state == GameState.Active, "Not active");
        require(msg.sender == game.playerB, "Only Player B can decide");
        
        game.playerBDecision = takeOpponentBox;
        game.decisionMade = true;
        game.state = GameState.Decided;
        game.decidedAt = block.timestamp;
        
        // Trigger decryption of the carrot location
        FHE.decrypt(game.playerAHasCarrot);
        
        emit DecisionMade(gameId, takeOpponentBox);
    }
    
    /**
     * @notice Finalize the game after coFHE decryption is ready
     */
    function finalizeGame(uint256 gameId) external nonReentrant {
        Game storage game = games[gameId];
        require(game.state == GameState.Decided, "Not decided or already resolved");
        
        (bool result, bool ready) = FHE.getDecryptResultSafe(game.playerAHasCarrot);
        require(ready, "Decryption not ready");
        
        bool playerAHasCarrot = result;
        game.playerAHasCarrotRevealed = playerAHasCarrot;
        
        address winner;
        if (game.playerBDecision) {
            winner = playerAHasCarrot ? game.playerB : game.playerA;
        } else {
            winner = playerAHasCarrot ? game.playerA : game.playerB;
        }
        
        game.winner = winner;
        game.state = GameState.Resolved;
        
        uint256 pot = game.stake * 2;
        activeGameCount[game.playerA]--;
        activeGameCount[game.playerB]--;
        
        require(carrotToken.transfer(winner, pot), "Prize transfer failed");
        emit GameResolved(gameId, winner, pot, playerAHasCarrot);
    }
    
    function cancelGame(uint256 gameId) external nonReentrant {
        Game storage game = games[gameId];
        require(msg.sender == game.playerA, "Only creator");
        require(game.state == GameState.Open || 
               (game.state == GameState.Active && block.timestamp > game.joinedAt + DECISION_TIMEOUT), 
               "Cannot cancel");
        
        if (game.state == GameState.Open) {
            require(carrotToken.transfer(game.playerA, game.stake), "Refund failed");
            activeGameCount[game.playerA]--;
        } else {
            require(carrotToken.transfer(game.playerA, game.stake), "Refund A failed");
            require(carrotToken.transfer(game.playerB, game.stake), "Refund B failed");
            activeGameCount[game.playerA]--;
            activeGameCount[game.playerB]--;
        }
        
        game.state = GameState.Cancelled;
        emit GameCancelled(gameId, "Cancelled by creator or timeout");
    }

    // View functions
    function getGame(uint256 gameId) external view returns (Game memory) {
        return games[gameId];
    }
    
    function getBluffs(uint256 gameId) external view returns (Bluff[] memory) {
        return gameBluffs[gameId];
    }
    
    /**
     * @notice Check if a game's decryption is ready
     */
    function isDecrypted(uint256 gameId) external view returns (bool) {
        (, bool ready) = FHE.getDecryptResultSafe(games[gameId].playerAHasCarrot);
        return ready;
    }

    /**
     * @notice Get games for a specific user (created or joined)
     */
    function getMyGames(address user) external view returns (uint256[] memory) {
        uint256 count = 0;
        for (uint256 i = 1; i < nextGameId; i++) {
            if (games[i].playerA == user || games[i].playerB == user) {
                count++;
            }
        }
        
        uint256[] memory result = new uint256[](count);
        uint256 idx = 0;
        for (uint256 i = 1; i < nextGameId; i++) {
            if (games[i].playerA == user || games[i].playerB == user) {
                result[idx++] = i;
            }
        }
        return result;
    }

    /**
     * @notice Get open games for the lobby
     */
    function getOpenGames(uint256 offset, uint256 limit) external view returns (
        uint256[] memory gameIds,
        uint256[] memory stakes,
        address[] memory creators
    ) {
        uint256 count = 0;
        for (uint256 i = 1; i < nextGameId; i++) {
            if (games[i].state == GameState.Open) {
                count++;
            }
        }
        
        uint256 returnSize = count > offset ? count - offset : 0;
        if (returnSize > limit) returnSize = limit;
        
        gameIds = new uint256[](returnSize);
        stakes = new uint256[](returnSize);
        creators = new address[](returnSize);
        
        uint256 found = 0;
        uint256 added = 0;
        for (uint256 i = 1; i < nextGameId && added < returnSize; i++) {
            if (games[i].state == GameState.Open) {
                if (found >= offset) {
                    gameIds[added] = i;
                    stakes[added] = games[i].stake;
                    creators[added] = games[i].playerA;
                    added++;
                }
                found++;
            }
        }
        return (gameIds, stakes, creators);
    }


}
